클라이언트의 요청 결과를 Proxy를 통해 서버에 간접적으로 호출한다고 해보자.
여기서 Proxy는 일종의 '대리자'가 되며, 이게 바로 프록시.

- 객체가 프록시가 되려면, 클라이언트는 서버에게 요청한 것인지, 프록시에게 요청한 것인지 몰라야 한다.
: 즉, 서버와 프록시는 같은 인터페이스로부터 구현된 객체여야 한다.
: 서버를 프록시 객체로 변경해도, 클라이언트의 코드를 변경하지 않고도 동작이 가능해야 한다!

== 클라이언트는 서버 인터페이스에만 의존하고, 서버와 프록시가 같은 인터페이스를 사용하도록.
-> 런타임에 DI를 사용하면 객체의 의존관계를 변경해도 클라이언트의 코드를 변경할 필요가 없어진다!

-----------------

* 프록시의 주요 기능
- 접근 제어
: 권한에 따라 접근을 차단해버리기
: 캐싱 (더 빠르게)
: 지연 로딩
- 부가 기능의 추가


---------------

* GOF 디자인 패턴 - 프록시 / 데코레이터 패턴.
프록시의 경우 접근 제어가 목적이지만, 데코레이터의 경우 새로운 기능 추가가 목적이다.
데코레이터도 프록시를 사용하지만, 둘의 목적이 다른 것임!

** 디자인 패턴에서 중요한 거는 패턴을 만든 의도!

----------------

인터페이스 기반 프록시 vs 클래스 기반 프록시.
- 클래스 기반 프록시는 해당 클래스에만, 인터페이스 기반 프록시는 인터페이스만 같으면 가능!
- 단, 클래스 기반 프록시는 상속을 사용하기 때문에 제약이 존재한다.
: 부모 클래스의 생성자 호출
: 클래스나 메서드에 final이 붙으면 상속이 불가능, 오버라이딩도 불가능.

- 그러나, 인터페이스 기반 프록시는 인터페이스가 꼭 필요하다는 점이 단점이다.

---------------

JDK 동적 프록시 -> 인터페이스가 필수.
인터페이스가 없을 경우 동적 프록시를 적용하기 위해서는 CGLIB를 사용해야 한다.

** CGLIB
: 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술.
: 스프링의 ProxyFactory가 편리하게 사용하도록 도와준다!

- 단, 부모 클래스의 생성자가 필요하다.
- 클래스, 메서드에 final이 붙으면 상속, 오버라이딩이 안 되니까 프록시 로직이 실행 안 된다.

