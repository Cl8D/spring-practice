** 스프링 AOP
- Pointcut
: 부가기능을 어디에 사용할 것인지, 어디에 사용하지 않을지 적용.
클래스와 메서드 이름으로 필터링!
: 대상 여부를 확인하는 일종의 '필터' 역할

- Advice
: 프록시가 호출하는 부가 기능, 프록시 로직.
: 부가 기능을 로직만 담당.

- Advisor
: 하나의 포인트컷과 하나의 어드바이스를 가지고 있음.

==> 포인트컷으로 '어디에' 적용할지 선택, 어디바이스로 '어떤' 로직을 적용할지 선택.
==> 그리고, 이 두 가지를 모두 알고 있는 것이 어드바이저!

왜 이렇게 하는가? ==> 필터링 + 부가 기능을 하는 건 SRP 위배.
역할을 분명하게 분리하도록 하자!

----------------

* 빈 후처리기
: 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를
빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용한다.

** 빈 등록 과정
1. 스프링 빈 대상이 되는 객체를 관리한다.
2. 생성된 객체를 빈 저장소에 등록하기 전에, 빈 후처리기에 전달한다.
3. 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나, 다른 객체로 바꿔치기 할 수 있다
4. 빈 후처리기는 빈을 반환한다. 그대로 반환하면 빈이 등록되고, 바꿔치기 하면 다른 객체가 저장소에 저장된다.

---------------

* 포인트컷.
> 1. 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다. (빈 후처리기 - 자동 프록시 생성)
> 2. 프록시의 어떤 메서드가 호출 되었을 때 어드바이스를 적용할지 판단한다. (프록시 내부)

----------------

* 자동 프록시 생성기 - AnnotationAwareAspectJAutoProxyCreator
: 자동으로 프록시를 생성해주는 빈 후처리기.
: 스프링 빈으로 등록된 Advisor를 자동으로 찾아서, 프록시가 필요한 곳에 자동으로 적용해준다.
: Advisor는 Pointcut + advice이기 때문에, 포인트 컷을 통해 어떤 스프링 빈에 프록시를 적용해야 할지 알 수 있다.

** @Aspect 개념까지 합쳐보자면!
동작 과정)
1. 스프링 빈 대상이 되는 객체 생성
2. 생성된 객체를 빈 후처리기에 전달.
3-1. 빈 후처리기는 컨테이너에 등록된 모든 Advisor를 조회한다.
3-2. @Aspect 어드바이저 빌더 내부에 저장된 advisor롤 모두 조회한다.
4. 조회한 Advisor에 있는 포인트컷을 통해 해당 객체가 프록시를 적용할 대상인지 판단한다.
- 객체의 클래스 정보, 객체의 모든 메서드를 포인트컷에 하나하나 매칭한다.
- 클래스의 메서드 중 하나라도 포인트컷 조건에 만족한다면 프록시 적용 대상이 된다.
5. 적용 대상이면 프록시 생성하여 빈으로 등록하고, 아니라면 원본 객체를 빈으로 등록한다.
6. 반환된 객체를 스프링 빈으로 등록이 된다.

-----------------------

* 포인트컷 2가지 사용
1. 프록시 적용 여부 판단 - 생성 단계
: 자동 프록시 생성기는 포인트컷을 사용해서 해당 빈이 프록시 생성할 필요가 있는지 없는지 체크한다.
: 클래스 + 메서드 조건 비교 후, 포인트컷 조건에 하나하나 매칭한다.
--> 조건에 맞는 것이 하나라도 있으면 프록시 생성한다.

2. 어드바이스 적용 여부 판단 - 사용 단계
: 포인트컷을 보고 어드바이스를 적용할지 말지 판단한다.
: 포인트컷 조건에 만족하면 어드바이스를 호출->target 호출
: 만족하지 않으면 바로 targetㅇ르 호출한다.

-------------------

@Aspect를 Advisor로 어떻게 변환하는가?
- 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기 호출
- 스프링 컨테이너에서 @Aspect가 붙은 빈을 모두 조회
- @Aspect 어드바이저 빌더를 통해 어노테이션 정보를 기반으로 어드바이저 생성
: @Around에 입력한 정보를 바탕으로 포인트컷을, 그리고 아래 로직을 통해 Advice를.
: 이를 합쳐서 Advisor 정보를 만들어낸다고 생각하면 될 것 같다.
- 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다.

------------------

** AOP의 소개
- 애플리케이션 로직은 핵심 기능과 부가 기능.
핵심 기능은 객체가 제공하는 고유 기능, 부가 기능은 보조를 위한 기능.
- 부가 기능은 보통 여러 클래스에서 함께 사용된다. ==> "횡단 관심사"
- 이를 각 클래스의 코드 상에서 모두 호출한다면 매우 복잡해진다. 코드의 중복 발생, 수정 힘들어짐!
==> 어떻게 해결할 수 있을까?

--

<어떠한 부가 기능>을 <어디에 적용>할지 선택하는 기능을 합해서 하나의 모듈로 만들자!
== @Aspect.
: 애스팩트를 사용한 프로그래밍 방식이 바로 AOP (관점 지향 프로그래밍)
-> OOP를 대체하는 것이 아니라, OOP의 부족한 부분을 보조하는 게 AOP!

--

* 부가 기능을 실제 로직에 어떻게 추가할 것인가?
1) 컴파일 시점 == 위빙 (Weaving, 원본 로직 자체에 부가 기능 로직이 추가되는 것)
컴파일러가 .java -> .class로 만드는 시점에 추가하기.
이때는 Aspect에서 제공하는 컴파일러를 사용해야 하며, 컴파일 코드에 실제로 붙여버리는 방식이다.

2) 클래스 로딩 시점 == 로드 타임 위빙.
.class 파일은 JVM의 클래스 로더에 보관하는데,.class 파일 자체를 조작해버리는 것.
마찬가지로 위빙 방식으로, 코드에 부가 기능 호출 코드가 포함된다.
java -javaagent를 활용해서 특별한 클래스 로더 조작기를 써야 하는데, 어렵다.

3) 런타임 시점 (프록시)
컴파일, 그리고 클래스 로더에 클래스까지 다 올라가서 자바가 실행된 다음.
컨테이너의 도움, DI, 빈 포트스 프로세서 같은 개념을 모두 사용하는 것.
실제 코드가 유지되며, 스프링 AOP는 이 방식을 사용한다.

--

** AOP를 어디에 적용할 것인가? (조인 포인트)
- 바이트 코드를 조작하는 1, 2번 방식은 모든 지점에 가능.
- 런타임 시점에서는 <메서드 실행 시점>에만 AOP를 적용할 수 있따.
: 프록시는 메서드 오버라이딩 개념. -> 생성자, static, field 값 접근에는 X
- 스프링 AOP는 스프링 컨테이너가 관리하는 <<스프링 빈에만 AOP를 적용>>할 수 있다.

--

** 용어 정리
1) Join Point
: Advice가 적용될 수 있는 위치나 메서드의 실행, 생성자 호출 같은 프로그램이 실행되는 지점
: 일종의 'AOP를 적용할 수 있는' 지점. (어드바이스를 적용할 수 있는 지점!)
: 스프링 AOP는 항상 메서드 실행 시점으로 제한된다.
--> 항상 메서드를 실행해야 어드바이스를 적용할 수 있다.

2) PointCut
: Advice가 적용될 위치를 선별하는 기능.
: AspectJ 표현식을 사용

3) Target
: Advice를 받는 객체, 포인트컷으로 결정.

4) Advice
: 부가 기능!
: 특정한 '조인 포인트'에서 'Aspect'에 의해 취해지는 어떠한 코드, 조치.
: @Around, @Before, @After 같은 종류의 어드바이스가 있다.

5) Aspect
: Advice + Pointcut

6) Advisor
: 하나의 어드바이스, 하나의 포인트컷.

&) 위빙
- '포인트컷'으로 결정된 '타겟'의 '조인 포인트'에 '어드바이스'를 적용하는 것.
: 핵심 기능 코드에 영향을 주지 않고, 부가 기능 추가 가능.

7) AOP 프록시
: AOP 기능 구현을 위한 프록시 객체.
스프링에서는 JDK 동적 프록시, CGLIB 프록시가 있다.
